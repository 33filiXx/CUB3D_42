Door System Overview
=====================

This document explains how interactive doors are implemented and wired into the
`cub3D` demo. It covers the data structures in `inc/door.h`, the logic in
`src/game/door.c`, and the spots where the rest of the engine calls into the
door system.

1. Data Model (`inc/door.h`)
---------------------------
* Every door is represented by `t_door`. Persistent fields include the tile
  coordinates (`map_x`, `map_y`), the current animation fraction
  (`progress`, 0 = closed, 1 = fully open), an `enum` state (`CLOSED`,
  `OPENING`, `OPEN`, `CLOSING`), and metadata describing how the slab rotates:
  * `pivot`: world-space hinge point computed once during load.
  * `span_closed`: the door edge vector when the door is closed.
  * `rot_sign`: direction (+/-) the slab swings in.
  * `has_geom`: safety flag that geometry inference succeeded.
* `t_game_data` (see `inc/cub3d.h`) owns the global array `doors`, the count
  `door_count`, and a pointer to the `door_tex` texture used while rendering.

2. Loading Doors From the Map (`door_load_map` in `src/game/door.c`)
------------------------------------------------------------------
* The map parser simply marks door tiles with `'D'` in `map.grid`. At runtime
  `door_load_map` scans the grid, allocates/extends `data->doors`, and assigns
  one `t_door` per `'D'` tile.
* Each new door is zeroed via `append_to_doors`, initialized to `DOOR_CLOSED`,
  given a small opening speed (`speed = 0.1`), and immediately sent to
  `configure_door_geometry`.
* `configure_door_geometry` inspects the neighbours of the door tile to guess
  whether the slab should span horizontally or vertically. It tests both hinge
  sides (`hinge_signs`) and both swing directions (`rot_signs`), discarding any
  configuration whose open position would clip into a wall. The best candidate
  (preferring hinges embedded in walls) is stored on the `t_door`. If every
  option fails we fall back to a default hinge so the door still animates.
* `main()` (in `src/game/game.c`) calls `door_load_map(&game_data);` right after
  the map/door structures are initialised, so `door_count` and geometry are
  ready before the first render.

3. Player Interaction (`door_toggle` and `door_update`)
------------------------------------------------------
* Pressing the `E` key triggers `door_toggle` (bound inside `key_press` in
  `game.c`). The helper `get_front_cell` projects one unit forward from the
  player, snaps to a tile, and attempts to find a `t_door` there via
  `find_door`.
* `door_toggle` advances the finite state machine: `CLOSED`/`CLOSING` switches
  to `OPENING`, and `OPEN`/`OPENING` switches to `CLOSING`. The `progress`
  tracing the animation fraction is reset to the appropriate edge (0 for
  closed, 1 for open) when direction changes.
* `door_update` runs every frame from `game_loop`. It integrates time using the
  delta `dt` between frames, clamps `progress` to `[0,1]`, and flips the state
  to the resting value once the animation finishes. Whenever any door changes
  we invoke `redraw_map` to guarantee the frame buffer shows the new opening.

4. Collision and Movement Integration
-------------------------------------
* Movement functions (`move_forward`, `move_backwards`, etc.) rely on
  `valid_move`. After the usual wall bounds/`'1'` checks, `valid_move` calls
  `door_is_blocking(data, map_x, map_y)`.
* `door_is_blocking` looks up the door at that tile and applies conservative
  rules:
  * Fully open doors (`state == DOOR_OPEN`) never block.
  * Doors that are still opening block until `progress >= 0.95`, so the player
    can slide through only when the gap is clearly visible.
  * Closing or closed doors always block.
* This keeps traversal physically consistent with the raycast view; the player
  can’t step through a door that still appears mostly shut.

5. Raycasting and Rendering (`src/game/render_3d.c`)
---------------------------------------------------
* During DDA traversal, whenever the ray enters a `'D'` tile we call
  `find_door` to retrieve the runtime door object. We skip doors that are
  almost closed (`progress >= 0.99`) so closed slabs behave exactly like walls.
* `door_ray_intersection` performs an analytic segment intersection between the
  current ray and the animated door span:
  * The span vector is rotated by `progress * rot_sign * 90°` (`door_current_span`).
  * We solve for the distance `t` along the ray and barycentric coordinate `s`
    along the door slab. Hits are accepted only when `t > 0` and `0 ≤ s ≤ 1`.
* When a hit is found, `set_door_data` overwrites the raycast result (`rc.kind`
  becomes `HIT_DOOR`, `perp_wall_dist` stores the door hit distance, and
  `wall_x` stores the local `u` coordinate). The render loop then selects
  `tex.door_tex` instead of the wall textures and samples it using the computed
  `tex_x`. The same ceiling/floor painting and z-buffer logic is reused.
* Door geometry data (`door->progress`) is also written to `rc.door_progress` so
  other systems could react if needed (e.g., shading or audio cues).

6. Texture Setup
----------------
* `tex_ready` in `render_3d.c` loads the dedicated `../../textures/door.xpm`
  texture once per run, alongside the four wall textures. The `door_tex` handle
  lives in the static `t_st` struct so every ray column can switch to it
  whenever `rc.kind == HIT_DOOR`.

7. Summary of Control Flow
--------------------------
1. **Startup:** `init_doors` zeroes the array, `door_load_map` builds it from the
   parsed map, and the door texture is loaded lazily by `tex_ready` during the
   first render.
2. **Runtime:**
   * Input (`E`) → `door_toggle` flips a door state.
   * `game_loop` → `door_update` progresses animations and triggers redraws.
   * Movement → `valid_move` consults `door_is_blocking` for collisions.
   * Rendering → DDA checks `'D'` cells, invokes `door_ray_intersection`, and
     draws with `door_tex` when a door is the closest hit.
3. **Result:** Doors swing open around a computed hinge, move smoothly thanks
   to `progress * speed`, prevent the player from clipping through, and render
   with a dedicated texture that respects depth and z-buffer ordering.

With this flow, adding a door to any map is as simple as placing a `'D'`
character; the engine takes care of geometry inference, animation, collision,
and drawing automatically.
