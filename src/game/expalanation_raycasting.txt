# Cub3D Raycasting Algorithm - Complete Explanation

## Overview
Raycasting creates a 3D perspective view from a 2D map by casting rays from the player's position through each screen column, finding where they hit walls, and drawing vertical slices based on distance.

---

## Your Data Structures

### t_player
```c
typedef struct s_player
{
    t_vec2  pos;            // Player position in grid coordinates (e.g., 2.5, 13.5)
    t_vec2  dir;            // Direction vector - where player faces (normalized)
    t_vec2  plane;          // Camera plane - perpendicular to dir (defines FOV)
    double  move_speed;     // Movement speed (0.05 = 5% of a grid cell per frame)
    double  rot_speed;      // Rotation speed in radians (0.05 ≈ 2.86°)
    int     moving_forward; // State flags for continuous movement
    int     moving_backward;
    int     rotating_left;
    int     rotating_right;
} t_player;
```

**Key Concepts:**
- `pos`: Exact position in the grid (can be fractional, e.g., 2.5 = middle of cell 2)
- `dir`: Unit vector pointing where you look (length ≈ 1.0)
- `plane`: Defines your field of view width
  - Perpendicular to `dir`
  - Length determines FOV: 0.66 ≈ 66° horizontal FOV
  - If `dir = (0, -1)` (north), then `plane = (0.66, 0)` (east-west)

### t_raycast
```c
typedef struct s_raycast
{
    double  camera_x;        // X-position on camera plane (-1 to +1)
    double  ray_dir_x;       // Ray direction X component
    double  ray_dir_y;       // Ray direction Y component
    int     map_x;           // Current grid X coordinate being checked
    int     map_y;           // Current grid Y coordinate being checked
    double  side_dist_x;     // Distance ray travels to next X grid line
    double  side_dist_y;     // Distance ray travels to next Y grid line
    double  delta_dist_x;    // Distance between X grid lines along ray
    double  delta_dist_y;    // Distance between Y grid lines along ray
    double  perp_wall_dist;  // Perpendicular distance to wall (prevents fisheye)
    int     step_x;          // Direction to step in X (-1 or +1)
    int     step_y;          // Direction to step in Y (-1 or +1)
    int     hit;             // Was a wall hit? (0 or 1)
    int     side;            // Which wall side hit? (0=X-side, 1=Y-side)
} t_raycast;
```

---

## The Algorithm Step-by-Step

### STEP 1: Calculate Ray Direction for Screen Column X

```c
// For each screen column (x = 0 to screen_width)
data->rc.camera_x = 2 * x / (double)view_width - 1;
```
- Maps screen X to camera plane position
- Left edge (x=0): `camera_x = -1`
- Center (x=width/2): `camera_x = 0`
- Right edge (x=width): `camera_x = +1`

```c
data->rc.ray_dir_x = data->player.dir.x + data->player.plane.x * data->rc.camera_x;
data->rc.ray_dir_y = data->player.dir.y + data->player.plane.y * data->rc.camera_x;
```
- Ray starts at player position
- Ray direction = player's look direction + offset along camera plane
- This creates the "cone" of vision

**Example:**
- Player: `dir=(0,-1)`, `plane=(0.66,0)`
- Left ray (camera_x=-1): `ray_dir = (0,-1) + (0.66,0)*(-1) = (-0.66, -1)`
- Center ray (camera_x=0): `ray_dir = (0,-1) + (0.66,0)*(0) = (0, -1)`
- Right ray (camera_x=+1): `ray_dir = (0,-1) + (0.66,0)*(+1) = (0.66, -1)`

---

### STEP 2: Initialize DDA Variables

```c
data->rc.map_x = (int)data->player.pos.x;  // Starting grid cell X
data->rc.map_y = (int)data->player.pos.y;  // Starting grid cell Y
```
- Converts player position (e.g., 2.5, 13.5) to grid indices (2, 13)

```c
data->rc.delta_dist_x = (data->rc.ray_dir_x == 0) ? 1e30 : fabs(1 / data->rc.ray_dir_x);
data->rc.delta_dist_y = (data->rc.ray_dir_y == 0) ? 1e30 : fabs(1 / data->rc.ray_dir_y);
```
- **delta_dist_x**: How far ray travels to cross one X grid line
- **delta_dist_y**: How far ray travels to cross one Y grid line
- If ray is horizontal (ray_dir_y=0), delta_dist_y = infinity (never crosses Y lines)

**Visual:**
```
Ray going northeast (dir_x=1, dir_y=-1):
├─X─┼─X─┼─X─┤  delta_dist_x = distance between X crossings
│   │   │   │
Y   Y   Y   Y  delta_dist_y = distance between Y crossings
│   │   │   │
```

---

### STEP 3: Calculate Step Direction and Initial Side Distance

```c
if (data->rc.ray_dir_x < 0)  // Ray going left
{
    data->rc.step_x = -1;
    data->rc.side_dist_x = (data->player.pos.x - data->rc.map_x) * data->rc.delta_dist_x;
}
else  // Ray going right
{
    data->rc.step_x = 1;
    data->rc.side_dist_x = (data->rc.map_x + 1.0 - data->player.pos.x) * data->rc.delta_dist_x;
}
```
- **step_x/step_y**: Which direction to move in grid (-1 or +1)
- **side_dist_x/y**: Distance from player to FIRST grid line crossing

**Example:**
```
Player at (2.7, 5.0), ray going right (step_x=+1):
├───┼───X───┼───┤
    2   ^   3
        2.7
side_dist_x = (3.0 - 2.7) * delta_dist_x
            = 0.3 * delta_dist_x
            = distance to first vertical line
```

---

### STEP 4: Perform DDA (Digital Differential Analyzer)

```c
while (data->rc.hit == 0)
{
    // Choose which grid line to cross next
    if (data->rc.side_dist_x < data->rc.side_dist_y)
    {
        data->rc.side_dist_x += data->rc.delta_dist_x;  // Move to next X line
        data->rc.map_x += data->rc.step_x;
        data->rc.side = 0;  // Hit X-side of wall
    }
    else
    {
        data->rc.side_dist_y += data->rc.delta_dist_y;  // Move to next Y line
        data->rc.map_y += data->rc.step_y;
        data->rc.side = 1;  // Hit Y-side of wall
    }
    
    // Check bounds
    if (data->rc.map_x < 0 || data->rc.map_x >= data->map.width ||
        data->rc.map_y < 0 || data->rc.map_y >= data->map.height)
        break;
    
    // Check if we hit a wall
    if (data->map.grid[data->rc.map_y][data->rc.map_x] == '1')
        data->rc.hit = 1;
}
```

**What's Happening:**
1. Compare distances to next X-line vs Y-line
2. Step to whichever is closer
3. Check if that grid cell is a wall ('1')
4. Repeat until wall is hit or out of bounds

**Visual:**
```
Player (P) casting ray northeast:
┼─────┼─────┼─────┼
│     │     │  1  │  Step 4: Hit wall!
P─────2─────3─────4
│     │     │     │
┼─────┼─────┼─────┼

Steps:
1. side_dist_x < side_dist_y → cross X line, map_x++
2. side_dist_y < side_dist_x → cross Y line, map_y--
3. side_dist_x < side_dist_y → cross X line, map_x++
4. grid[map_y][map_x] == '1' → hit = 1
```

---

### STEP 5: Calculate Perpendicular Wall Distance

```c
if (data->rc.side == 0)  // Hit X-side
    data->rc.perp_wall_dist = (data->rc.map_x - data->player.pos.x + 
                               (1 - data->rc.step_x) / 2) / data->rc.ray_dir_x;
else  // Hit Y-side
    data->rc.perp_wall_dist = (data->rc.map_y - data->player.pos.y + 
                               (1 - data->rc.step_y) / 2) / data->rc.ray_dir_y;
```

**Why Perpendicular Distance?**
- Prevents fisheye effect
- Uses distance to wall projected onto camera direction, not actual ray length

**Visual:**
```
Top view:
        │ wall
        │
    ╱───┤  euclidean distance (causes fisheye)
  ╱  ┊  │
P────┴──┤  perpendicular distance (correct)
    camera
    plane

Perpendicular distance keeps walls straight on screen.
```

**Formula Breakdown:**
- `(map_x - player.pos.x)`: Grid cells traveled in X
- `+ (1 - step_x) / 2`: Adjust to wall face (0.5 if going right, -0.5 if going left)
- `/ ray_dir_x`: Convert to distance units

---

### STEP 6: Calculate Wall Height on Screen

```c
int line_height = (int)(view_height / data->rc.perp_wall_dist);
```
- Closer walls → smaller distance → larger height
- Further walls → larger distance → smaller height
- This creates perspective!

```c
int draw_start = -line_height / 2 + view_height / 2;
if (draw_start < 0) draw_start = 0;

int draw_end = line_height / 2 + view_height / 2;
if (draw_end >= view_height) draw_end = view_height - 1;
```
- Center the wall vertically on screen
- Clamp to screen bounds

**Example:**
```
view_height = 960
perp_wall_dist = 2.0
line_height = 960 / 2.0 = 480

draw_start = -480/2 + 960/2 = -240 + 480 = 240
draw_end   = 480/2 + 960/2 = 240 + 480 = 720

Screen column:
  0 ────────┐
           │ ceiling
 240 ───────┤
           │ wall (480 pixels tall)
 720 ───────┤
           │ floor
 960 ────────┘
```

---

### STEP 7: Draw Vertical Stripe

```c
int color = (data->rc.side == 0) ? 0xFF0000 : 0x880000;

// Ceiling
while (y < draw_start)
    put_pixel(&data->mlx, start_x + x, y++, ceiling_color);

// Wall
while (y <= draw_end)
    put_pixel(&data->mlx, start_x + x, y++, color);

// Floor
while (y < view_height)
    put_pixel(&data->mlx, start_x + x, y++, floor_color);
```

- Each screen column is one complete vertical stripe
- Y-sides darker than X-sides (simple shading)

---

## Key Formulas Summary

| Formula | Purpose |
|---------|---------|
| `camera_x = 2*x/width - 1` | Map screen X to camera plane (-1 to +1) |
| `ray_dir = player.dir + player.plane * camera_x` | Calculate ray direction |
| `delta_dist = fabs(1 / ray_dir)` | Distance to cross one grid line |
| `side_dist = (next_line - pos) * delta_dist` | Distance to first grid crossing |
| `perp_dist = (map - pos + offset) / ray_dir` | Perpendicular wall distance |
| `line_height = screen_height / perp_dist` | Wall height on screen |

---

## Common Issues & Solutions

### Fisheye Effect
**Problem:** Walls curve at screen edges  
**Cause:** Using euclidean distance instead of perpendicular  
**Solution:** Use perpendicular distance formula (step 5)

### Walls Not Aligned
**Problem:** Wall textures/heights don't match up  
**Cause:** Wrong side calculation or step direction  
**Solution:** Ensure `side` tracks X-side (0) vs Y-side (1) correctly

### Gaps in Walls
**Problem:** Black lines between wall slices  
**Cause:** Rounding errors or missing pixels  
**Solution:** Use `<=` in draw loops, not `<`

### Texture Stretching
**Problem:** Textures look stretched or compressed  
**Cause:** Not accounting for actual wall distance  
**Solution:** Calculate `wall_x` (exact hit point) for texture mapping

---

## Next Steps: Adding Textures

To add wall textures, you'll need to:
1. Calculate `wall_x` - exact hit point on wall (0.0 to 1.0)
2. Map `wall_x` to texture column
3. For each pixel in the wall stripe, calculate texture Y coordinate
4. Sample texture pixel and draw it

**wall_x calculation:**
```c
double wall_x;
if (side == 0)  // X-side
    wall_x = player.pos.y + perp_wall_dist * ray_dir.y;
else  // Y-side
    wall_x = player.pos.x + perp_wall_dist * ray_dir.x;
wall_x -= floor(wall_x);  // Get fractional part (0.0 to 1.0)

int tex_x = (int)(wall_x * texture_width);
```

---

## Memory Layout Reference

**Your structs use this data flow:**
```
main() initialization:
  ↓
t_game_data
├── t_file_data (textures, colors)
├── t_map (grid, width, height)
├── t_player (pos, dir, plane, speeds)
├── t_raycast (temporary per-ray data)
└── t_mlx (rendering context)
  ↓
game_loop() → render_3d_view()
  ↓
For each screen X:
  1. Calculate ray_dir using player.dir + player.plane
  2. Step through grid using DDA
  3. Find wall hit using map.grid
  4. Calculate perp_wall_dist
  5. Draw vertical stripe using mlx
```

---

## Performance Tips

1. **Pre-calculate constants:**
   - `delta_dist` only depends on ray direction
   - Can cache trig values for rotation

2. **Integer optimization:**
   - DDA uses only addition (no multiplication in inner loop)
   - Grid stepping is very fast

3. **Reduce draw calls:**
   - One `put_pixel` per pixel (no overdraw)
   - Can batch writes to image buffer

4. **Texture optimization:**
   - Load textures once at startup
   - Use pointer arithmetic for texture lookups

---

## Testing Checklist

- [ ] Can move forward/backward without passing through walls
- [ ] Can rotate left/right smoothly
- [ ] Walls render at correct heights (closer = taller)
- [ ] No fisheye effect at screen edges
- [ ] Ceiling and floor colors display correctly
- [ ] X-sides and Y-sides have different brightness
- [ ] No segfaults when looking at map edges
- [ ] Smooth 60 FPS movement

---

## Debugging Your Raycasting

**Print debug info for center ray:**
```c
if (x == view_width / 2)  // Center of screen
{
    printf("Center ray:\n");
    printf("  ray_dir: (%.2f, %.2f)\n", ray_dir_x, ray_dir_y);
    printf("  hit wall at: (%d, %d)\n", map_x, map_y);
    printf("  side: %d (0=X, 1=Y)\n", side);
    printf("  distance: %.2f\n", perp_wall_dist);
    printf("  wall height: %d pixels\n", line_height);
}
```

**Visualize rays on 2D map:**
```c
// In your draw_env(), draw the center ray
double ray_len = 5.0;
int end_x = (int)((player.pos.x + ray_dir.x * ray_len) * TILE);
int end_y = (int)((player.pos.y + ray_dir.y * ray_len) * TILE);
// Draw line from player to end point
```

---

## Mathematical Background

**Why does this work?**

1. **Similar Triangles:** Wall height on screen is inversely proportional to distance
   ```
   screen_height / wall_height_on_screen = distance / actual_wall_height
   ```

2. **Vector Addition:** Ray direction is sum of look direction and camera offset
   ```
   ray = dir + plane * camera_x
   ```

3. **Parametric Lines:** DDA efficiently steps along: `point = start + t * direction`

4. **Projection:** Perpendicular distance projects 3D world onto 2D plane
   ```
   perp_dist = euclidean_dist * cos(angle_to_camera)
   ```

---

## Resources

- **Lode's Raycasting Tutorial:** Classic guide (what Cub3D is based on)
- **Permadi's Tutorial:** Math-heavy explanation
- **Wikipedia DDA:** Digital Differential Analyzer algorithm
- **42 Cub3D Subject:** Your project requirements

---

**Good luck with your Cub3D! This algorithm is the foundation of classic 3D games like Wolfenstein 3D (1992). You're recreating gaming history! 🎮**